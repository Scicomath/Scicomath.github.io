<center><h2>Large-Scale C++: 声明、定义与Linkage</h2></center>

<textarea class="markdown">
	## 介绍
	
	最近在读John Lakos的《Large-Scale C++: Process and Architecture》, 现在读到了1.3节：Declarations, Definitions, and Linkage，写一下本节读书笔记。

	我感觉Lakos的书挺难读的，除了C++本身比较难之外，他写书的语言也挺绕的，动不动就一个超长的长句，对于我这种英语水平一般的读者来说，理解起来挺困难的。不过我觉得再难也要坚持啃下去，因为我觉得这本书非常有价值。

	在一个程序的构建过程中最常见的事情就是将一个**被命名的实体**（named entities）与它的定义结合起来。这里的“被命名的实体“有点太过抽象了，简单的来说就是那些可以有名字的一些”东西“，比如变量，函数，类型还有模板，这些都属于被命名的实体。在代码中，我们会大量的用这些实体的名字来指代这些实体。对于编译器来说，名字本身，对编译器是没有任何意义的，它是指一个代号而已。当我们在程序里面使用一个名字的时候，我们其实指的是名字背后对应的那个实体（不管它是变量还是函数等等）。每个实体必须有一个唯一的**定义**（definition），而**声明**（declaration）就是联系名字和定义的”中间人“。为什么要有”声明“这个”中间人“呢？因为定义必须是唯一的，所以它只能出现在一个地方，而名字可能在很多地方、很多文件中被用到。而每一个cpp文件都是一个编译单元，即都是单独编译成对应的.o文件，在编译的时候编译器必须知道这个编译单元里面的名字是什么东西。注意，编译器不必知道一个编译单元里面所有的名字对应的实体的定义，但必须知道所有名字的”基本信息“，而声明就是用来提供这些基本信息的。

	上面说到，在一个编译单元里面，可能会有一些实体没有定义，只有声明。但是这个实体的定义必须在某一个编译单元中存在。在这些编译单元各自编译成.o的目标文件之后，通过链接程序来把这些声明的实体与其定义关联起来，最后生成一个完整的可执行程序。

	未完待续。。。

	
</textarea>